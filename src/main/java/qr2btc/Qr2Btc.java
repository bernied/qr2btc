package qr2btc;

import com.google.zxing.BinaryBitmap;
import com.google.zxing.DecodeHintType;
import com.google.zxing.LuminanceSource;
import com.google.zxing.ReaderException;
import com.google.zxing.Result;
import com.google.zxing.ResultPoint;
import com.google.zxing.client.j2se.BufferedImageLuminanceSource;
import com.google.zxing.common.HybridBinarizer;
import com.google.zxing.multi.qrcode.QRCodeMultiReader;

import javax.imageio.ImageIO;
import java.awt.image.BufferedImage;
import java.io.IOException;
import java.nio.file.FileSystems;
import java.nio.file.Path;
import java.util.Arrays;
import java.util.Comparator;
import java.util.EnumMap;
import java.util.Iterator;
import java.util.Map;
import java.util.SortedSet;
import java.util.TreeSet;

/**
 * A simple class to read a scanned "paper wallet with hidden art" in .png form
 * generated by http://bitaddress.org.
 * @author Bernhard Damberger
 */
public class Qr2Btc
{
  private final QRCodeMultiReader barcodeReader;
  private final float ERROR;

  /**
   * Constructor.
   * @param error floating point error for calculating ordering of qr codes by position
   */
  public Qr2Btc(float error)
  {
    ERROR = error;
    barcodeReader = new QRCodeMultiReader();
  }

  /**
   * Constructor defaulting to error of 5.0f.
   */
  public Qr2Btc()
  {
    this(100.0f);
  }

  /**
   * Main entry point for printing out the bitcoin address followed by the private key.
   * @param args list of .png scans of wallets
   * @throws Exception
   */
  public static void main(String[] args)
      throws Exception
  {
    if (args.length < 1)
    {
      System.err.println("Expecting a list of .png image files to process.");
      System.exit(-1);
    }

    Qr2Btc qr2btc = new Qr2Btc();

    // Process list of assumed .png files
    for (int i=0; i < args.length; i++)
    {
      Path p = FileSystems.getDefault().getPath(args[i]);
      String[] keys = qr2btc.decodeMultiple(p);
      for (int j=0; j < keys.length; j++)
      {
        String addr = keys[j++];
        String privKey = keys[j];
        System.out.println(addr + "\t" + privKey);
      }
    }
  }

  private BinaryBitmap createBitmap(BufferedImage img)
  {
    assert img != null;
    LuminanceSource source = new BufferedImageLuminanceSource(img);
    return new BinaryBitmap(new HybridBinarizer(source));
  }

  /**
   * Decodes a single QR code from the .png image.
   * @param btcImage path to image containing QR code
   * @return String representation of code
   * @throws IOException
   * @throws ReaderException
   */
  public String decode(Path btcImage)
      throws IOException, ReaderException
  {
    BufferedImage image = ImageIO.read(btcImage.toFile());
    BinaryBitmap bitmap  = createBitmap(image);

    return decode(bitmap, false);
  }

  /**
   * Decodes a single QR code from the .png image.
   * @param source image w/ qr code
   * @param tryHarder tells zxing to "try harder"
   * @return String representation of QR code
   * @throws ReaderException
   */
  public String decode(BinaryBitmap source, boolean tryHarder)
      throws ReaderException
  {
    Map<DecodeHintType,Object> hints = new EnumMap<>(DecodeHintType.class);
    if (tryHarder) {
      hints.put(DecodeHintType.TRY_HARDER, Boolean.TRUE);
    }

    Result result = barcodeReader.decode(source, hints);
    String resultText = result.getText();

    return resultText;
  }

  /**
   * Decodes multiple QR codes from the .png image and orders them by position (l->r, t->b)
   * @param btcImage path to image w/ qr codes
   * @return array of Strings containing bitcoin address followed by private key, etc
   * @throws IOException
   * @throws ReaderException
   */
  public String[] decodeMultiple(Path btcImage)
      throws IOException, ReaderException
  {
    BufferedImage image = ImageIO.read(btcImage.toFile());
    BinaryBitmap bitmap  = createBitmap(image);

    return decodeMultiple(bitmap, true);
  }

  /**
   * Decodes multiple QR codes from the .png image and orders them by position (l->r, t->b)
   * @param source image that contains multiple qr codes
   * @param tryHarder tells zxing to "try harder"
   * @return array of Strings containing bitcoin address followed by private key, etc
   * @throws IOException
   * @throws ReaderException
   */
  public String[] decodeMultiple(BinaryBitmap source, boolean tryHarder)
      throws IOException, ReaderException
  {
    Map<DecodeHintType,Object> hints = new EnumMap<>(DecodeHintType.class);
    if (tryHarder) {
      hints.put(DecodeHintType.TRY_HARDER, Boolean.TRUE);
    }

    Result[] result = barcodeReader.decodeMultiple(source, hints);
    result = orderResults(result);

    String[] data = new String[result.length];
    for (int i=0; i < data.length; i++) {
      data[i] = result[i].getText();
    }

    return data;
  }

  private Result[] orderResults(Result[] result)
  {
    assert result.length % 2 == 0;
    SortedSet<Result> split = new TreeSet<Result>(new Comparator<Result>()
    {
      @Override
      public int compare(Result lhs, Result rhs)
      {
        ResultPoint lhsTL = lhs.getResultPoints()[0];
        ResultPoint rhsTL = rhs.getResultPoints()[0];

        if (Math.abs(lhsTL.getX() - rhsTL.getX()) < ERROR)
        {
          return Float.compare(lhsTL.getY(), rhsTL.getY());
        }
        return Float.compare(lhsTL.getX(), rhsTL.getX());
      }
    });
    split.addAll(Arrays.asList(result));

    // Order the values so that its bitcoin address followed by its private key
    // followed by the next bitcoin address and private key,
    // until there are no more.
    int i=0;
    Result[] orderedResults = new Result[result.length];
    Iterator<Result> iter = split.iterator();
    while(iter.hasNext())
    {
      if (i > result.length-1) {
        break;
      }
      orderedResults[i] = iter.next();
      i += 2;
    }

    i=1;
    while (iter.hasNext())
    {
      orderedResults[i] = iter.next();
      i += 2;
    }

    return orderedResults;
  }
}
